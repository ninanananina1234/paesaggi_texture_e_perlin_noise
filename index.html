<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="utf-8">
    <title>Paesaggi, Textures e Perlin Noise</title>
    <meta name="author" content="Nome Cognome">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Space+Grotesk:wght@700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --primary: #fff;
            --secondary: #000;
            --accent: #e0e0e0;
            --bg: #111;
            --text: #fff;
            --section-gap: 8vh;
            --radius: 24px;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.18);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', 'Space Grotesk', Arial, sans-serif;
            scroll-behavior: smooth;
        }

        body {
            min-height: 100vh;
            overflow-x: hidden;
        }

        main {
            width: 100vw;
            max-width: 100vw;
            margin: 0;
            padding: 0;
        }

        header {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--secondary);
            color: var(--primary);
            position: relative;
            overflow: hidden;
        }

        header h1 {
            font-family: 'Space Grotesk', 'Inter', sans-serif;
            font-size: clamp(3rem, 8vw, 7rem);
            font-weight: 700;
            letter-spacing: -0.04em;
            margin-bottom: 1.2rem;
            line-height: 1.05;
            text-shadow: 0 2px 32px #0008;
            animation: fadeInUp 1.2s cubic-bezier(.6, 0, .4, 1);
        }

        .sottotitolo {
            font-size: 1.5rem;
            opacity: 0.8;
            max-width: 700px;
            margin: 0 auto 2.5rem auto;
            text-align: center;
            animation: fadeInUp 1.6s cubic-bezier(.6, 0, .4, 1);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(60px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section {
            width: 100vw;
            max-width: 100vw;
            margin: 0 auto;
            padding: var(--section-gap) 0;
            background: var(--bg);
            position: relative;
            overflow: hidden;
            transition: background 0.6s cubic-bezier(.6, 0, .4, 1);
        }

        .section.alt {
            background: var(--secondary);
            color: var(--primary);
        }

        .section .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .section-title {
            font-family: 'Space Grotesk', 'Inter', sans-serif;
            font-size: clamp(2.2rem, 5vw, 3.5rem);
            font-weight: 700;
            margin-bottom: 2.5rem;
            letter-spacing: -0.02em;
            line-height: 1.1;
            position: relative;
            z-index: 2;
            animation: fadeInUp 1.2s cubic-bezier(.6, 0, .4, 1);
        }

        .section-content {
            font-size: 1.25rem;
            line-height: 1.7;
            max-width: 900px;
            margin: 0 auto;
            animation: fadeInUp 1.5s cubic-bezier(.6, 0, .4, 1);
        }

        .section img,
        .section .img {
            transition: none;
        }

        .esempio-card img {
            /* width: 100%; */
            /* height: 180px; */
            object-fit: unset;
            box-shadow: var(--shadow);
            border-radius: var(--radius);
            display: block;
            margin: 0 auto 1rem auto;
        }

        .esempio-card img:hover {
            transform: none;
        }

        .formula {
            background: #222;
            color: #fff;
            padding: 1.2rem 1rem;
            border-radius: 12px;
            font-family: monospace;
            margin: 1.5rem 0;
            font-size: 1.1rem;
            overflow-x: auto;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 2rem;
            margin: 2.5rem 0;
        }

        .grid .esempio-card {
            background: #181818;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .grid .esempio-card img {
            width: 100%;
            /*height: 220px;  /* altezza fissa ma non eccessiva */
            object-fit: contain;  /* mantiene le proporzioni senza tagliare */
            /*background: #222;  /* sfondo scuro per le immagini con trasparenza */
            /*padding: 10px;  /* spazio interno per non far toccare i bordi */
        }

        .esempio-card-content {
            padding: 1.2rem 1rem 1.5rem 1rem;
            flex-grow: 1;  /* occupa lo spazio rimanente */
        }

        .esempio-card h5 {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #fff;
        }

        .controlli {
            background: #181818;
            border-radius: var(--radius);
            padding: 1rem 1rem;
            margin: 1.5rem 0 1rem 0;
            box-shadow: var(--shadow);
        }

        .slider-container {
            margin-bottom: 0.8rem;
        }

        .slider-container label {
            font-weight: 700;
            margin-bottom: 0.2rem;
            display: block;
            font-size: 0.9rem;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #5af;
            height: 6px;
        }

        #perlinCanvas,
        #perlinWebGL {
            width: 100%;
            max-width: 900px;
            height: 400px;
            background: #fff;
            border-radius: var(--radius);
            margin: 2rem auto;
            display: block;
            box-shadow: var(--shadow);
        }

        #perlinCanvas {
            background: #fff;
        }

        #perlinWebGL {
            background: #111;
        }

        .bibliografia {
            margin-top: 2.5rem;
            font-size: 1.1rem;
        }

        .bibliografia ul {
            list-style: none;
            padding: 0;
        }

        .bibliografia li {
            margin-bottom: 0.7rem;
            padding-left: 1.2rem;
            position: relative;
        }

        .bibliografia li::before {
            content: "•";
            position: absolute;
            left: 0;
            color: #5af;
        }

        a {
            color: #5af;
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            text-decoration: underline;
            color: #fff;
        }

        @media (max-width: 900px) {
            .section .container {
                padding: 0 1rem;
            }

            .section-title {
                font-size: 2rem;
            }
        }

        @media (max-width: 600px) {
            header h1 {
                font-size: 2.2rem;
            }

            .section-title {
                font-size: 1.3rem;
            }

            .section-content {
                font-size: 1rem;
            }
        }

        /* Animazioni scroll dinamiche */
        .fade-in {
            opacity: 0;
            transform: translateY(60px);
            transition: opacity 1.2s cubic-bezier(.6, 0, .4, 1), transform 1.2s cubic-bezier(.6, 0, .4, 1);
        }

        .fade-in.visible {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>

<body>
    <main>
        <header>
            <h1>Paesaggi, Texture <br> e Perlin Noise</h1>
            <div class="sottotitolo">Il rumore di Perlin è un algoritmo scritto da Ken Perlin per produrre sequenze che
                appaiono sia casuali che organiche.</div>
        </header>
        <section class="section fade-in">
            <div class="container">
                <h2 class="section-title">Che cos'è il Perlin Noise?</h2>
                <div class="section-content">
                    <p>Il Perlin Noise è un algoritmo di generazione procedurale sviluppato da Ken Perlin nel 1983
                        mentre lavorava agli effetti speciali del film "Tron". Questo algoritmo produce sequenze di
                        numeri che appaiono sia casuali che organiche, cioè con una coerenza spaziale che imita fenomeni
                        naturali. Dagli anni 90 quasi tutta la CGI è basata sul Perlin Noise. Viene usato da artisti, sviluppatori di videogiochi e web-designer.I vantaggi di questo algoritmo comprndono anche la ridezione del lavoro manuale di creazione contenuti e il fatto che occupa meno spazio (si salva il "seed", non tutti i dati).</p>
                    <div style="display: flex; gap: 1rem; justify-content: center; margin: 1.5rem 0;">
                    
                        <img src="img/TRON_5.jpg" alt="Tron 3"
                            style="width: 100%; object-fit: cover; border-radius: 8px;">
                    </div>
                    <p>A differenza del rumore completamente casuale (rumore bianco), il Perlin Noise crea transizioni
                        graduali e naturali tra i valori. Questa caratteristica lo rende perfetto per generare texture,
                        terreni, nuvole, fumo e molti altri elementi che richiedono un aspetto organico ma con un certo
                        grado di casualità.</p>
                    <p>Perlin ricevette un Oscar tecnico nel 1997 per questo contributo alla computer grafica,
                        dimostrando l'importanza fondamentale di questo algoritmo nell'industria dell'intrattenimento e
                        della simulazione.</p>
                    <div id="perlinIntro"
                        style="width:100%; height:200px; background:#000; border-radius:16px; margin:2rem 0;"></div>
                </div>
            </div>
        </section>
        <section class="section alt fade-in">
            <div class="container">
                <h2 class="section-title">La Matematica del Perlin Noise</h2>
             
                <div class="section-content">
                    <p> <strong>Una guida semplificata alla comprensione dei concetti base dell'algoritmo di Ken Perlin.</strong>  </p>
                        
                    <p style="font-size:1.3rem;">Dal punto di vista matematico, il Perlin Noise è una funzione di interpolazione che genera valori attraverso una serie di processi.</p>
                    <p style="font-size:1.3rem;">Il vantaggio del Perlin Noise è che lo si può applicare a ogni quantità di dimensioni. <br>Il costo computazionale del Perlin Noise cresce esponenzialmente al crescere delle dimensioni.<br>Partendo dal presupposto che in tutti i casi il primo passaggio nell'esecuzione del Perlin Noise è la suddivisione del piano in una griglia, (in 1D → punti; in 2D → quadrati; in 3D → cubi) per 1D prendiamo 2 numeri, per 2D ne prendiamo 4 (vertici del quadrato), per 3D ne serviranno 8 (vertici del cubo), etc.</p>
                    <strong>Processo</strong>  

                    <ul style="padding:0px; margin-left: 0rem; margin-bottom: 1.5rem;">
                        <li><strong>Pseudo-random:</strong> Per iniziare ci servono valori pseudo-random tra -1 e 1 (vettori nel caso del 2D). Ad esempio possiamo partire dalle funzioni sin o cos, per generare una funzione pseudo-random.<br><img src="img/Perlin_Noise_2-01.png" alt="Rumore bianco" style="width:100%;margin:0.5em 0;"></li>
                        <li><strong>Prodotto scalare:</strong> Otteniamo il prodotto scalare tra i numeri (o vettori) e i loro offset (valore successivo nel piano). Da notare come passando sull'asse x del piano cartesiano (per 1D) o tra i nodi di griglia (per 2D ecc.) il valore del prodotto sia sempre 0. Questo è ciò che conferisce all'algoritmo il suo aspetto caratteristico.<br></li><br>
                        <li><strong>Steps:</strong> Componiamo la funzione «floor» dei prodotti scalari (così prendiamo solo i numeri interi, per semplificare) creando gli step tra i nostri valori.<br><img src="img/Perlin_Noise_2-02.png"  alt="Rumore interpolato" style="width:100%;margin:0.5em 0;"></li>
                        <li><strong>Interpolazione:</strong> Con la funzione Smooth (funzione sigmoidea),  applicata alla nostra funzione, otteniamo una linea morbida (per 1D), un gradiente morbido (per 2D), o una superficie (per 3D). La funzione Smooth in poche parole «smussa» i nostri «gradini» tra i valori.<br><img src="img/Perlin_Noise_2-03.png" style="width:100%;margin:0.5em 0;"><br><img src="img/Perlin_Noise_2-04.png" alt="Rumore interpolato" style="width:100%;margin:0.5em 0;"></li>
                        <li><strong>Ottave:</strong> Per rendere la funzione più organica, più complessa e più interessante dobbiamo aggiungere le ottave - moltiplicare, sommare e comporre tra loro più funzioni di noise con valori diversi.<br><br><img src="img/Perlin_Noise_2-05.png"  style="width:100%;margin:0.5em 0;"><br><img src="img/Perlin_Noise_2-06.png" style="width:100%;margin:0.5em 0;" ><br><img src="img/Perlin_Noise_2-07.png"style="width:100%;margin:0.5em 0;"></li></li>
                        <li><strong>Risultato:</strong> <br><img src="img/Perlin_Noise_2-08.png" alt="Rumore frattale" style="width:100%;margin:0.5em 0;"></li>

                    </ul>
                    <li><strong>Formula di base</strong> </li>
                    <div class="formula"><strong>PerlinNoise(x) = lerp(fade(t), grad(a, x), grad(b, x - 1))</strong></div>
                    <p>Dove:</p>
                    <ul>
                        <li>x è il punto da valutare (tra due interi a e b: a = floor(x), b = a + 1)</li>
                        <li>t = x - a (la parte frazionaria di x)</li>
                        <li>fade(t) è una funzione di smoothing</li>
                        <li>grad(hash, x) è una funzione gradiente basata su un valore hash</li>
                        <li>lerp(t, a, b) è l'interpolazione lineare</li>
                    </ul>
                   
                    <p style="font-size:0.95em; opacity:0.8;">Fonte: <a href="http://tobyschachman.com/Shadershop/" target="_blank">Shadershop - Toby Schachman</a></p>
                </section>
                <section class="section alt fade-in">
                    <div class="container">
                        <h2 class="section-title">Esempio Interattivo: Griglia di Punti con Perlin Noise</h2>
                        <div class="section-content">
                            <p>Sperimenta con il Perlin Noise modificando i parametri qui sotto. Osserva come i diversi valori
                                influenzano la dimensione dei punti nella griglia.</p>
                            <canvas id="perlinCanvas" width="900" height="400"></canvas>
                            <div class="controlli">
                                <div class="slider-container">
                                    <label for="gapSlider">Distanza tra i punti: <span id="gapValue">20</span>px</label>
                                    <input type="range" id="gapSlider" min="5" max="40" step="1" value="20">
                                </div>
                                <div class="slider-container">
                                    <label for="scaleSlider">Scala: <span id="scaleValue">0.01</span></label>
                                    <input type="range" id="scaleSlider" min="0.001" max="0.05" step="0.001" value="0.01">
                                </div>
                                <div class="slider-container">
                                    <label for="octavesSlider">Ottave: <span id="octavesValue">3</span></label>
                                    <input type="range" id="octavesSlider" min="1" max="8" step="1" value="3">
                                </div>
                                <div class="slider-container">
                                    <label for="persistenceSlider">Persistenza: <span id="persistenceValue">0.5</span></label>
                                    <input type="range" id="persistenceSlider" min="0.1" max="0.9" step="0.05" value="0.5">
                                </div>
                            </div>
                            <ul style="margin-left: 1.5rem; margin-bottom: 1.5rem;">
                                <li><strong>Distanza tra i punti</strong>: Controlla la spaziatura della griglia. Una distanza
                                    maggiore mostra meglio i pattern del rumore su larga scala.</li>
                                <li><strong>Scala</strong>: Controlla quanto "zoom" si applica al rumore. Valori più piccoli
                                    producono variazioni più graduali.</li>
                                <li><strong>Ottave</strong>: Il numero di livelli di dettaglio sovrapposti. Più ottave creano un
                                    rumore più complesso e dettagliato.</li>
                                <li><strong>Persistenza</strong>: Controlla quanto ogni ottava successiva influisce sul
                                    risultato finale. Valori più alti creano più dettaglio e "turbolenza".</li>
                            </ul>
                            <p>Nota come il Perlin Noise crea modelli che appaiono sia casuali che organici: i punti vicini
                                hanno dimensioni simili, creando un effetto di gradualità che imita fenomeni naturali. Questo è
                                molto diverso dalla casualità pura, dove non ci sarebbe alcuna coerenza spaziale.</p>
                        </div>
                    </div>
                </section>
                <section class="section fade-in">
                    <div class="container">
                        <h2 class="section-title">Esempio Interattivo: Paesaggio 3D in Perlin Noise (rotazione con mouse)</h2>
                        <div class="section-content">
                            <p>Trascina il mouse orizzontalmente per ruotare il paesaggio. </p>
                            <canvas id="perlinWebGL" width="900" height="400"></canvas>
                            <div class="controlli">
                                <div class="slider-container">
                                    <label for="webglOctavesSlider">Ottave: <span id="webglOctavesValue">3</span></label>
                                    <input type="range" id="webglOctavesSlider" min="1" max="8" step="1" value="3">
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
        </section>
        <section class="section fade-in">
            <div class="container">
                <h2 class="section-title">Cosa Si Può Creare con il Perlin Noise?</h2>
                <div class="section-content">
                    <p>Il Perlin Noise trova applicazione in numerosi campi della computer grafica e del design
                        procedurale. Ecco alcuni degli utilizzi più comuni:</p>
                    <div class="grid">
                        <div class="esempio-card"><img src="img/Attack_of_the_clones_STARWARS.jpeg"  alt="Generazione di terreni">
                            <div class="esempio-card-content">
                                <div class="esempio-card"><img src="img/necessary-disorder_2.gif"  alt="Generazione di terreni">
                                    <div class="esempio-card-content"></div>
                                    <div class="esempio-card"><img src="img/rainforest.png"  alt="Generazione di terreni">
                                        <div class="esempio-card-content"></div>
                                   

                            <h5>Generazione di terreni</h5>
                                <p>Usato per creare paesaggi naturalistici in videogiochi e simulazioni geografiche.</p>
                            </div>
                        </div>
                        <div class="esempio-card"><img src="img/dailydrawbot_1.gif" alt="Texture procedurali">
                            <div class="esempio-card-content">
                                <div class="esempio-card"><img src="img/necessary-disorder_1.gif" alt="Texture procedurali">
                                    <div class="esempio-card-content">
                                        <div class="esempio-card"><img src="img/necessary-disorder_4.gif" alt="Texture procedurali">
                                            <div class="esempio-card-content">

                                <h5>Texture procedurali</h5>
                                <p>Creazione di texture.</p>
                            </div>
                        </div>
                        <div class="esempio-card"><img src="img/clouds.png" alt="Animazioni organiche">
                            <div class="esempio-card-content">
                                <div class="esempio-card"><img src="img/sea.png" alt="Animazioni organiche">
                                    <div class="esempio-card-content">
                                <h5>Animazioni organiche</h5>
                                <p>Movimento di personaggi, fluidi, fuoco e fenomeni atmosferici.</p>
                            </div>
                        </div>
                        <div class="esempio-card"><img src="img/raven_kwork_1.gif" alt="Generazione di mappe">
                            <div class="esempio-card-content">
                                <div class="esempio-card"><img src="img/raven_kwork_2.gif" alt="Generazione di mappe">
                                    <div class="esempio-card-content">
                                <h5>Performance</h5>
                                <p>Utilizzo del Perlin Noise da parte di artisti contemporanei. Un esempio è l'opera di Raven Kwork.</p>
                            </div>
                        </div>
                    </div>
                    <p>Il Perlin Noise è spesso combinato con altre tecniche procedurali per ottenere risultati ancora
                        più complessi e realistici, come l'erosione simulata per i terreni o la combinazione con
                        algoritmi di flusso per simulare fiumi e strade.</p>
                </div>
            </div>
        </section>
        <section class="section fade-in">
            <div class="container">
                <h2 class="section-title">Altre Tipologie di Noise</h2>
                <div class="section-content">
                    <p>Oltre al Perlin Noise, esistono altre tipologie di noise molto utilizzate in computer grafica e generazione procedurale. Qui sotto trovi una breve descrizione, un link a un esempio su Shadertoy e uno spazio per confrontare visivamente ogni tipo di noise.</p>
                    <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 2rem; margin: 2.5rem 0;">
                        <div class="esempio-card">
                            <img src="img/White.png" alt="White Noise" style="width:100%;max-width:320px;height:180px;object-fit:cover;display:block;margin:0 auto 1rem auto;border-radius:var(--radius);">
                            <div class="esempio-card-content">
                                <h5>White Noise</h5>
                                <p>Il rumore bianco è completamente casuale, con valori indipendenti per ogni pixel. Utile come base per altri tipi di noise.</p>
                                <a href="https://www.shadertoy.com/view/MlVSzw" target="_blank">Esempio su Shadertoy</a>
                            </div>
                        </div>
                        <div class="esempio-card">
                            <img src="img/Gaussian.png" alt="Gaussian Noise" style="width:100%;max-width:320px;height:180px;object-fit:cover;display:block;margin:0 auto 1rem auto;border-radius:var(--radius);">
                            <div class="esempio-card-content">
                                <h5>Gaussian Noise</h5>
                                <p>Una distribuzione normale dei valori di rumore, che segue una curva gaussiana. Spesso usato per simulare fenomeni naturali.</p>
                                <a href="https://www.shadertoy.com/view/Mty3Dh" target="_blank">Esempio su Shadertoy</a>
                            </div>
                        </div>
                        <div class="esempio-card">
                            <img src="img/Simplex.png" alt="Perlin Noise" style="width:100%;max-width:320px;height:180px;object-fit:cover;display:block;margin:0 auto 1rem auto;border-radius:var(--radius);">
                            <div class="esempio-card-content">
                                <h5>Simplex Noise</h5>
                                <p>Una versione semplificata del Perlin Noise</p>
                                <a href="https://www.shadertoy.com/view/Msf3WH" target="_blank">Esempio su Shadertoy</a>
                            </div>
                        </div>
                        <div class="esempio-card">
                            <img src="img/Voronoi.png" alt="Voronoi Noise" style="width:100%;max-width:320px;height:180px;object-fit:cover;display:block;margin:0 auto 1rem auto;border-radius:var(--radius);">
                            <div class="esempio-card-content">
                                <h5>Voronoi Noise</h5>
                                <p>Un tipo di noise che genera pattern cellulari, spesso usato per simulare pietre, pelle, o strutture organiche.</p>
                                <a href="https://www.shadertoy.com/view/Xd23Dh" target="_blank">Esempio su Shadertoy</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
       
        
        <section class="section alt fade-in">
            <div class="container">
                <h2 class="section-title">Bibliografia e Risorse</h2>
                <div class="bibliografia">
                    <ul>
                        <li><a target="_blank" href="https://en.wikipedia.org/wiki/Perlin_noise">Wikipedia: Perlin
                                Noise</a></li>
                        <li><a target="_blank" href="https://mrl.cs.nyu.edu/~perlin/noise/">Ken Perlin: Sito ufficiale
                                con implementazione originale</a></li>
                        <li><a target="_blank" href="https://www.khronos.org/opengl/wiki/Procedural_Texturing">OpenGL
                                Wiki: Procedural Texturing</a></li>
                        <li><a target="_blank" href="https://thebookofshaders.com/11/">The Book of Shaders: Noise</a>
                        </li>
                        <li><a target="_blank" href="https://p5js.org/reference/p5/noise/">NoiseJS: Implementazione
                                JavaScript del Perlin Noise</a></li>
                        <li><a target="_blank" href="http://tobyschachman.com/Shadershop/">Toby Schachman</a></li>
                        <li><a target="_blank" href="https://iquilezles.org/">Inigo Quilez</a></li>
                        <li><a target="_blank" href="https://www.shadertoy.com/">Shadertoy</a></li>
                        <li><a target="_blank" href="https://www.imdb.com/title/tt0084827/">TRON</a></li>
                        <li><a target="_blank" href="https://ravenkwok.tumblr.com/">Raven Kwork</a></li>
                        <li><a target="_blank" href="https://www.imdb.com/title/tt0121765/">Star Wars Episode II Attack of the Clones</a></li>
                        <li><a target="_blank" href="https://necessary-disorder.tumblr.com/">Etienne Jacob</a></li>
                        <li><a target="_blank" href="https//dailydrawbot.tumblr.com/">Just van Rossum</a></li>
                        <li><a target="_blank" href="https://www.youtube.com/watch?v=BFld4EBO2RE">Painting landscape
                                with math</a></li>
                        <li><a target="_blank" href="https://rtouti.github.io/graphics/perlin-noise-algorithm">Perlin
                                noise algorithm</a></li>
                        <li><a target="_blank"
                                href="https://www.cs.umd.edu/class/spring2018/cmsc425/Lects/lect13-2d-perlin.pdf">Dave
                                Mount & Roger Eastman</a></li>
                    </ul>
                </div>
            </div>
        </section>
    </main>
    <script>
        // Improved Perlin Noise + fBm (come nel file originale)
        class ImprovedNoise {
            constructor() {
                this.p = new Uint8Array(512);
                this.permutation = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
                for (let i = 0; i < 256; i++) {
                    this.p[i] = this.p[i + 256] = this.permutation[i];
                }
            }
            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);
                const A = this.p[X] + Y;
                const AA = this.p[A] + Z;
                const AB = this.p[A + 1] + Z;
                const B = this.p[X + 1] + Y;
                const BA = this.p[B] + Z;
                const BB = this.p[B + 1] + Z;
                return this.lerp(w,
                    this.lerp(v,
                        this.lerp(u,
                            this.grad(this.p[AA], x, y, z),
                            this.grad(this.p[BA], x - 1, y, z)
                        ),
                        this.lerp(u,
                            this.grad(this.p[AB], x, y - 1, z),
                            this.grad(this.p[BB], x - 1, y - 1, z)
                        )
                    ),
                    this.lerp(v,
                        this.lerp(u,
                            this.grad(this.p[AA + 1], x, y, z - 1),
                            this.grad(this.p[BA + 1], x - 1, y, z - 1)
                        ),
                        this.lerp(u,
                            this.grad(this.p[AB + 1], x, y - 1, z - 1),
                            this.grad(this.p[BB + 1], x - 1, y - 1, z - 1)
                        )
                    )
                );
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
        }
        function fbm(perlin, x, y, z, octaves, persistence) {
            let total = 0, frequency = 1, amplitude = 1, maxValue = 0;
            for (let i = 0; i < octaves; i++) {
                total += perlin.noise(x * frequency, y * frequency, z * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            return total;
        }
        function initIntroAnimation() {
            const container = document.getElementById('perlinIntro');
            const canvas = document.createElement('canvas');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            container.innerHTML = '';
            container.appendChild(canvas);
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(canvas.width, canvas.height);
            const data = imgData.data;
            const perlin = new ImprovedNoise();
            let z = 0;
            function render() {
                z += 0.01;
                for (let x = 0; x < canvas.width; x++) {
                    for (let y = 0; y < canvas.height; y++) {
                        const value = fbm(perlin, x * 0.01, y * 0.01, z, 4, 0.5);
                        const idx = (y * canvas.width + x) * 4;
                        const color = Math.floor(value * 255);
                        data[idx] = color;
                        data[idx + 1] = color;
                        data[idx + 2] = color;
                        data[idx + 3] = 255;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                requestAnimationFrame(render);
            }
            render();
        }
        function initDotGridExample() {
            const canvas = document.getElementById('perlinCanvas');
            const ctx = canvas.getContext('2d');
            const gapSlider = document.getElementById('gapSlider');
            const scaleSlider = document.getElementById('scaleSlider');
            const octavesSlider = document.getElementById('octavesSlider');
            const persistenceSlider = document.getElementById('persistenceSlider');
            const gapValue = document.getElementById('gapValue');
            const scaleValue = document.getElementById('scaleValue');
            const octavesValue = document.getElementById('octavesValue');
            const persistenceValue = document.getElementById('persistenceValue');
            const perlin = new ImprovedNoise();
            function drawDotGrid() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const gap = parseInt(gapSlider.value);
                const scale = parseFloat(scaleSlider.value);
                const octaves = parseInt(octavesSlider.value);
                const persistence = parseFloat(persistenceSlider.value);
                gapValue.textContent = gap;
                scaleValue.textContent = scale.toFixed(3);
                octavesValue.textContent = octaves;
                persistenceValue.textContent = persistence.toFixed(2);
                for (let x = gap / 2; x < canvas.width; x += gap) {
                    for (let y = gap / 2; y < canvas.height; y += gap) {
                        const noiseValue = fbm(perlin, x * scale, y * scale, 0, octaves, persistence);
                        const normalizedValue = (noiseValue + 1) / 2;
                        const radius = Math.max(1, normalizedValue * gap * 1.2);
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${normalizedValue * 1.5})`;
                        ctx.fill();
                    }
                }
            }
            gapSlider.addEventListener('input', drawDotGrid);
            scaleSlider.addEventListener('input', drawDotGrid);
            octavesSlider.addEventListener('input', drawDotGrid);
            persistenceSlider.addEventListener('input', drawDotGrid);
            drawDotGrid();
        }
        function initPerlinWebGL() {
            const canvas = document.getElementById('perlinWebGL');
            const ctx = canvas.getContext('2d');
            const perlin = new ImprovedNoise();
            const octavesSlider = document.getElementById('webglOctavesSlider');
            const octavesValue = document.getElementById('webglOctavesValue');
            const risoluzione = 80;
            const spaziatura = 6;
            const elevazione = 200;
            let rotY = 0.0;
            let dragging = false;
            let lastX = 0;
            canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.offsetX; });
            window.addEventListener('mouseup', () => dragging = false);
            window.addEventListener('mousemove', e => { if (dragging) { rotY += (e.offsetX - lastX) * 0.01; lastX = e.offsetX; } });
            function project3D([x, y, z]) {
                let X = x;
                let Y = y * Math.cos(-0.5) - z * Math.sin(-0.5);
                let Z = y * Math.sin(-0.5) + z * Math.cos(-0.5);
                let X2 = X * Math.cos(rotY) - Z * Math.sin(rotY);
                let Z2 = X * Math.sin(rotY) + Z * Math.cos(rotY);
                const scale = 350 / (350 + Z2);
                return [canvas.width / 2 + X2 * scale, canvas.height / 2 + Y * scale];
            }
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const offsY = performance.now() * 0.01 / 16.67;
                const t = 0;
                const octaves = parseInt(octavesSlider.value);
                octavesValue.textContent = octaves;
                for (let j = -risoluzione / 2; j < risoluzione / 2; j++) {
                    const z = j * spaziatura;
                    ctx.beginPath();
                    for (let i = -risoluzione / 2; i < risoluzione / 2; i++) {
                        const x = i * spaziatura;
                        let y = fbm(perlin, i * 0.03 + 100, j * 0.04 + offsY, t, octaves, 0.5) * elevazione - elevazione / 2;
                        y = Math.min(y, 0);
                        const [sx, sy] = project3D([x, y, z]);
                        if (i === -risoluzione / 2) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.strokeStyle = (j === 0) ? "rgb(255,0,0)" : "rgb(180,180,180)";
                    ctx.lineWidth = 1.2;
                    ctx.stroke();
                }
                requestAnimationFrame(draw);
            }
            octavesSlider.addEventListener('input', () => {
                // Force redraw when slider changes
                draw();
            });
            draw();
        }
        window.addEventListener('load', function () {
            initIntroAnimation();
            initDotGridExample();
            initPerlinWebGL();
            // Scroll animation
            const fadeEls = document.querySelectorAll('.fade-in');
            const onScroll = () => {
                fadeEls.forEach(el => {
                    const rect = el.getBoundingClientRect();
                    if (rect.top < window.innerHeight * 0.85) {
                        el.classList.add('visible');
                    }
                });
            };
            window.addEventListener('scroll', onScroll);
            onScroll();
        });
    </script>
</body>

</html>